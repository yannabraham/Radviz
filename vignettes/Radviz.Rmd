---
title: "Visualizing Multivariate Data with Radviz"
author: "Yann Abraham"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Visualizing Multivariate Data with Radviz}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r,echo=FALSE}
knitr::opts_chunk$set(warning=FALSE,
                      fig.retina=1,
                      fig.keep='high',
                      fig.align='center')
```


# Abstract

The Radviz package implements the concept of dimensional anchors to visualize multivariate datasets in a 2D projection, as originally described in [Hoffman *et al* 1999](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.135.889). Additional work for ordering of dimensional anchor is taken from [Di Caro *et al* 2012](http://link.springer.com/chapter/10.1007/978-3-642-13672-6_13).

# Introduction

So called big data has focused our attention on datasets that comprise a large number of items (or *things*). As a consequence the fact that we are measuring (or recording) more and more parameters (or *stuff*) is often overlooked, even though this large number of *things* is enabling us to explore the relationships between the different *stuff* with unprecedented efficacy.

Yet, this increase in the *stuff* we measure comes with a so-called Curse of Dimensionality: as our brains are unable to efficiently deal with more than 3 dimensions, we need new tools to visually explore larger (more than 3 dimensions) sets.

Several such tools exist that rely on projection into lower number of dimensions, such as PCA. Although those tools represent an efficient solution, they do not allow for direct interpretation of the position of the points in space.

Radviz provides an elegant solution to this problem, by projecting a N-dimensional data set into a simple 2D space where the influence of each dimension can be interpreted as a balance between the influence of all dimensions.

## Building a radviz projection

In Radviz, each dimension in the dataset is represented by a dimensional anchor, and each dimensional anchor is distributed evenly on a unit circle. Each line in the data set corresponds to a point in the projection, that is linked to every dimensional anchor by a spring. Each spring's stiffness corresponds to the value for that particular *thing* in that particular dimension. The position of the point is defined as the point in the 2D space where the spring's tension is minimum.

## Installation

The package can be installed using the following command:

```
devtools::install_github('yannabraham/Radviz')
```

Once installed the package can be loaded using the standard `library` command.

```{r,warning=FALSE}
library(Radviz)
```

## Getting help

The various functions described in this vignette all have dedicated help pages with code examples, such as

```{r,eval=FALSE}
?do.radviz
```

```{r}
example("do.radviz")
```

# Step by step example: the `cars` data set

Radviz examples use the Iris dataset, which contains only 4 dimensions. For this vignette we will use the `mtcars` dataset, which contains 11 dimensions

```{r}
data(mtcars)
head(mtcars)
dim(mtcars)
```

## Normalizing the data

Radviz requires that all dimensions have the same range. The simplest way to achieve that is to normalize every numerical column to its range, so that all values fall in the `[0,1]` interval. The `do.L` function performs this operation for us:

```{r}
norm.cars <- apply(mtcars,2,do.L)
head(norm.cars)
summary(norm.cars)
```

## Defining the anchors

Let's define a Spring object that contains the position of each dimension on the unit circle. The dimensions will be matched by column name to the data, so it is important to make sure that column names are syntactically valid.

```{r}
colnames(norm.cars) <- make.names(colnames(norm.cars))
```

The `make.S` function will take a vector of column names and return a matrix of `[x,y]` positions. The order of the column names will dictate the position on the circle, starting at 12:00 and going clockwise. It is not required to use all avaiable columns: it might be worth splitting the dimensions
depending on what they represent (continuous versus categorical variables, phenotypic versus functional markers, etc.).

```{r}
S <- make.S(colnames(norm.cars))
```

## Projection

The `do.radviz` function will then use the normalized values and the **S**prings to project each *thing* in a 2D space:

```{r}
rv <- do.radviz(norm.cars,S)
```

## Visualizing the results

There is a S3 `plot` function defined for radviz; using the default will give the following result

```{r}
plot(rv)
```

One can modify the shape of the points using the `point.shape` argument:

```{r}
plot(rv,point.shape=1)
```

Or color each dot using the `point.color` argument

```{r}
plot(rv,point.shape=1,point.color=mtcars$gear-2)
```

Even such a simple visualization allows us to identify 3 cars that have 3 gears but cluster together with cars that have 4 gears. Their position in the radviz projection suggests a larger influence of **qsec** over **disp**.

## Optimizing the position of anchors

The position of dimensional anchors on the circle is critical: the best projection (as judged by the separation of points in the display) is achieved when dimensional anchors that correspond to highly correlated dimensions in the data are placed closer on the unit circle.

Optimization of the position of dimensional anchors is discussed in [Di Caro *et al* 2012](http://link.springer.com/chapter/10.1007/978-3-642-13672-6_13), where the authors suggest 2 metrics that can be used in an optimization process. Both methods start with a similarity matrix where every value represents the similarity between any 2 dimensions. The first method assumes that dimensional anchors corresponding to similar dimensions should be close on the circle (radviz-independent); the second method uses a projection of the similarity matrix in radviz and computes the distance of the dimensional anchors to the projected dimensions they represent
(radviz-dependent) [Di Caro *et al* 2012](http://link.springer.com/chapter/10.1007/978-3-642-13672-6_13).

The radviz-dependent and independent methods have been implemented in the `Radviz` package, as well as the recommended cosine similarity measure.

```{r}
## compute the similarity matrix
sim.mat <- cosine(norm.cars)
## the current radviz-independent measure of projection efficiency
in.da(S,sim.mat)
## the current radviz-independent measure of projection efficiency
rv.da(S,sim.mat)
```

The radviz-independent score should be maximal when the dimensional anchor positions are optimal. The radviz-dependent score should be minimal when the dimensional anchor positions are optimal.

The optimization procedure works as follows:

```{r}
new <- do.optim(S,sim.mat,iter=10,n=100)
new.S <- make.S(tail(new$best,1)[[1]])
new.rv <- do.radviz(norm.cars,new.S)
```

The optimized radviz can then be visualized

```{r}
plot(new.rv,point.shape=1,point.color=mtcars$gear-2)
```

It becomes clear that there is at least 4, if not 5 distinct groups of cars in the dataset.

The optimization procedure can also be visualized using the data contained in `new`:

```{r}
plot(-new$perfs,type='l',
		xlab='# of Iterations',
		ylab='Performance'
)
```

# Application: CyTOF data

## Getting the data

We will use data from the [Bodenmiller *et al* 2012](http://www.nature.com/nbt/journal/v30/n9/full/nbt.2317.html) publication. The [bodenmiller](https://github.com/yannabraham/bodenmiller) package contains a subset of the data that can be used for testing purpose. The package can be installed by running the following command:

```
devtools::install_github('yannabraham/bodenmiller')
```

## Radviz projection of Phenotypic channels

Phenotypic data extracted from the `flowFrame` object and transformed using the arcsinh function is projected using radviz:

```{r}
library(bodenmiller)
# loading the data
data(refPhenoMat)
data(refFuncMat)
data(refMat)
data(refAnnots)
# normalize the data to min and max of each dimension
norm <- apply(refMat,2,function(x) {
    cx <- quantile(x,c(0.025,0.975))
    x[x<cx[1]] <- cx[1]
    x[x>cx[2]] <- cx[2]
    x <- (x-cx[1])/diff(cx)
    return(x)
  }
)
# perform radviz on phenotypic markers
ct.S <- make.S(dimnames(refPhenoMat)[[2]])
ct.sim <- cosine(norm)
# optimize the dimensional anchors
optim.ct <- do.optim(ct.S,ct.sim,iter=100,n=1000)
ct.S <- make.S(tail(optim.ct$best,1)[[1]])
ct.rv <- do.radviz(norm,ct.S)
```

```{r}
plot(ct.rv)
```

This simple plot is already enough to show some of the underlying structure of the dataset.

Using standard visualizations developed for FACS data analysis, one can further explore the data. The first alternative uses smoothed densities returned by a kernel density estimate to generate a 2D density plot:

```{r}
smoothRadviz(ct.rv)
```

Another alternative is to generate a contour plot from the data using the do.density function:

```{r}
ct.rv <- do.density(ct.rv,n=100)
```

Resulting in the following plot:

```{r}
contour(ct.rv)
```

## Visualizing Signal Intensity for Functional Channels

Further insight can be gained from the use of hexagonal binning:

```{r}
library(colorspace)
ct.rv <- do.hex(ct.rv,n=60,
		colramp=function(x) diverge_hcl(x),
		channels=dimnames(refFuncMat)[[2]],
		ncols=7,
		use.quantile=T
)
```

Leading to the following plot:

```{r}
hexplot(ct.rv,mincnt=5)
```

Each bin can then be colored according to other dimensions in the dataset, such as S6 phosphorylation:

```{r}
hexplot(ct.rv,mincnt=2,color='pS6')
```

To be compared with phospho-Akt signal:

```{r}
hexplot(ct.rv,mincnt=2,color='pAkt')
```

And phospho-Erk signal:

```{r}
hexplot(ct.rv,mincnt=2,color='pErk')
```

## Visualizing Cell Populations

Cells have been manually gated, leading to 14 sub-populations:

```{r,results='asis'}
ksink <- lapply(levels(refAnnots$Cells),function(x) cat(' *',x,'\n'))
```

To visualize the different populations, we compute a median phenotypic signal intensity by cell population, and project it in radviz:

```{r}
pop.norm <- apply(refMat,2,function(x) {
    cx <- quantile(x,c(0.025,0.975))
    x[x<cx[1]] <- cx[1]
    x[x>cx[2]] <- cx[2]
    x <- (x-cx[1])/diff(cx)
    x <- tapply(x,refAnnots$Cells,median)
    return(x)
  }
)
pop.rv <- do.radviz(pop.norm,ct.S)
pop.size <- table(refAnnots$Cells)
pop.cols <- setNames(rainbow_hcl(length(levels(refAnnots$Cells))),
                     levels(refAnnots$Cells))
```

Populations are visualized as a bubble chart: the bubble position corresponds to the median signal intensity of each channel for this specific population, and the bubble size is proportional to the number of cells in this population:

```{r,fig.width=6,fig.height=3}
par(mfrow=c(1,2))
bubbleRadviz(pop.rv,
             bubble.color=pop.cols[dimnames(pop.norm)[[1]]],
             bubble.size=log(pop.size[dimnames(pop.norm)[[1]]]),
             scale=0.2
)
plot.new()
legend("center",
       legend=names(pop.cols),
       col=pop.cols,
       cex=0.8,
       pch=16,
       bty='n')
```

Alternatively, bubbles can be colored after signal intensity of a functional channel, such as S6:

```{r}
S6.cols <- setNames(colorRampPalette(blues9)(8)[cut(pop.norm[,'pS6'],
                                                    breaks=8,
                                                    labels=F,
                                                    include.lowest=TRUE)],
                    dimnames(pop.norm)[[1]])
bubbleRadviz(pop.rv,
             bubble.color=S6.cols[dimnames(pop.norm)[[1]]],
             bubble.fg='grey',
             bubble.size=log(pop.size[dimnames(pop.norm)[[1]]]),
             scale=0.2
)
```

The population with the highest pS6 signal intensity corresponds to *dendritic cells*.

# Future directions

Radviz is an efficient visualization for multivariate datasets that allow for direct interpretation of results. This package provides a starting point to apply radviz to several datasets with minimal effort. Future developments include:

 * Visualization of SPADE trees in radviz space
 * Implement vectorized radviz as described in [Sharko *et al* 2008](http://www.ncbi.nlm.nih.gov/pubmed/18988995)
